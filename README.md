### 红黑树的C++源码编写
1.性质:
- 红黑树的根与叶子结点(*虚拟的结点*)都为**黑色**
- 红黑树不存在两个**红色结点**相邻(*黑色结点相邻无所谓*)
- 红黑树从根节点到每一个叶子结点的路径上经过的**黑色结点**的个数是相同的

2.由性质可推出的隐藏要求:
- 每个红结点下的两个子结点肯定为黑色
- 新插入的结点默认为红色结点

3.常见的操作说明:
- 左旋
![rotate left](https://github.com/user-attachments/assets/dd0c74a8-447a-44ab-a60a-325cb103efa4)
- 右旋
![rotate right](https://github.com/user-attachments/assets/d72216a9-0579-4bc8-9cc7-a3649b41290d)

4.操作
红黑树可以转化为四阶B树，根据B树的规则指导进行插入删除操作，维持红黑树的性质

(1)**插入操作**

![rbt1](https://github.com/user-attachments/assets/ba6cd933-91ac-48ce-bd58-1a032dcaea71)

- 插入新结点为根节点的情况
  
将新结点变为黑色结点
- 父结点为黑色结点的情况
  
直接插入即可(新结点默认为红色，可以维持性质)
- 父结点层级未溢出(这一层的核心黑结点的两个分支并不全是红结点)且父结点为红色结点
> R-R或者L-L结构

选择父结点(它是新结点、父结点、祖父黑结点中最中间数值的结点，最适合做新的核心黑结点)与祖父核心黑结点，将它们的颜色交换，然后对祖父结点采取左旋(R-R)/右旋(L-L)操作，将父结点变为新的核心黑结点

> R-L或者L-R结构

首先对父结点进行左旋(R-L)/右旋(L-R)转变为R-R/L-L结构，然后按照上述操作即可
- 父结点层级已满(核心黑结点两个分支全是红色结点)

将核心黑色结点左右两边的分支结点全部变为黑色结点，自身变为红色结点，然后自身上溢，相当于在上一层级上新插入了一个红色结点，然后根据不同的插入情况进行调整
