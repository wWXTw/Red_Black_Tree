### 红黑树的C++源码编写
1.性质:
- 红黑树的根与叶子结点(*虚拟的结点*)都为**黑色**
- 红黑树不存在两个**红色结点**相邻(*黑色结点相邻无所谓*)
- 红黑树从根节点到每一个叶子结点的路径上经过的**黑色结点**的个数是相同的

2.由性质可推出的隐藏要求:
- 每个红结点下的两个子结点肯定为黑色
- 新插入的结点默认为红色结点

3.常见的操作说明:
- 左旋
![rotate left](https://github.com/user-attachments/assets/dd0c74a8-447a-44ab-a60a-325cb103efa4)
- 右旋
![rotate right](https://github.com/user-attachments/assets/d72216a9-0579-4bc8-9cc7-a3649b41290d)

4.操作
红黑树可以转化为四阶B树，根据B树的规则指导进行插入删除操作，维持红黑树的性质

(1)**插入操作**

![rbt1](https://github.com/user-attachments/assets/ba6cd933-91ac-48ce-bd58-1a032dcaea71)

- 插入新结点为根节点的情况
  
将新结点变为黑色结点
- 父结点为黑色结点的情况
  
直接插入即可(新结点默认为红色，可以维持性质)
- 父结点层级未溢出(这一层的核心黑结点的两个分支并不全是红结点)且父结点为红色结点
> R-R或者L-L结构

选择父结点(它是新结点、父结点、祖父黑结点中最中间数值的结点，最适合做新的核心黑结点)与祖父核心黑结点，将它们的颜色交换，然后对祖父结点采取左旋(R-R)/右旋(L-L)操作，将父结点变为新的核心黑结点

> R-L或者L-R结构

首先对父结点进行左旋(R-L)/右旋(L-R)转变为R-R/L-L结构，然后按照上述操作即可
- 父结点层级已满(核心黑结点两个分支全是红色结点)

将核心黑色结点左右两边的分支结点全部变为黑色结点，自身变为红色结点，然后自身上溢，相当于在上一层级上新插入了一个红色结点，然后根据不同的插入情况进行调整

(2)**删除操作**

与普通二叉树一样，红黑树的删除也是由上层向底层扩展，然后根据不同的底层情况进行操作，即寻找当前需要删除结点的前驱结点(或者后继结点)，替换数值(结点位置的颜色不变)，然后对替换后原数值的结点再次进行删除判断

以下是递归到底层后可能遇到的一些情况:

- 当前的结点有一个分支

这样的情况根据红黑树的性质来说只有一种可能，就是黑色结点的左分支或者右分支是红色结点，两个结点交换数值(颜色保持)，然后去删除这个红色结点即可

- 当前的结点为单个红色结点

直接删除即可

- 当前结点为单个黑色结点

> 兄弟节点有单个红色结点分支(无论父结点为黑或者红)

根据红色结点分支方向与兄弟结点方向的情况，又可以分为L-L,L-R,R-R,R-L这四种情况

以L-L与L-R情况为例:

(1)L-L情况下，兄弟结点是兄弟结点，父结点，分支结点中最中心的结点，因此对父结点进行右旋让兄弟结点成为核心结点，然后将兄弟结点的颜色调整至与父结点颜色一致，然后将父结点与分支结点的颜色全部变为黑色，维持删除的黑结点的层数平衡

(2)L-R情况下，分支结点成为最中心的结点，所以需要先对兄弟结点进行左旋转化为新的L-L情况，然后根据以上操作更新即可
> 兄弟节点有两个红色结点分支(无论父结点为黑或者红)

这是比单个红色结点分支更为充裕的情况，一般根据兄弟结点的方向选择对应的情况(L-L/R-R),进行对应的操作(右旋/左旋+变色)
> 兄弟节点没有红色结点分支(父结点为红色结点)

由于父结点为红色，故实际影响的黑色结点只有一层(删除结点和兄弟结点)，那么将父结点下放并染为黑色，将兄弟结点则变为红色，保持一层的黑色结点
> 兄弟节点没有红色结点分支(父结点为黑色结点)

这种情况说明影响了两层的黑色结点，但删除该结点后只有两个黑色结点，不可能维持两层的情况，故只能进行层数塌陷，具体操作方法是将父结点下放，兄弟结点变为红色，将下方结点的结点缺失转化为父结点位置的结点缺失，然后针对这种情况继续进行删除操作(如果这个缺失转移到顶部，整个红黑树坍陷了一层)
